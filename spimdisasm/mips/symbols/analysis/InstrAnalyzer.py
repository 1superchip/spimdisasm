#!/usr/bin/env python3

# SPDX-FileCopyrightText: Â© 2022 Decompollaborate
# SPDX-License-Identifier: MIT

from __future__ import annotations

from .... import common

from ... import instructions

from .RegistersTracker import RegistersTracker


class InstrAnalyzer:
    def __init__(self, funcVram: int) -> None:
        self.funcVram = funcVram

        self.referencedVrams: set[int] = set()
        "Every referenced vram found"
        self.referencedConstants: set[int] = set()
        "Every referenced constant found"

        self.referencedVramsInstrOffset: dict[int, int] = dict()

        # Branches
        self.branchInstrOffsets: dict[int, int] = dict()
        "key: branch instruction offset, value: target vram"

        self.branchTargetInstrOffsets: dict[int, int] = dict()
        "key: branch instruction offset, value: relative branch target"

        self.branchLabelOffsets: set[int] = set()

        # Function calls
        self.funcCallInstrOffsets: dict[int, int] = dict()
        "key: func call instruction offset, value: target vram"
        self.funcCallOutsideRangesOffsets: dict[int, int] = dict()
        "key: func call instruction offset, value: target vram which is outside the [0x80000000, 0x84000000] range"

        # Jump register (jumptables)
        self.jumpRegisterIntrOffset: dict[int, int] = dict()
        self.referencedJumpTableOffsets: dict[int, int] = dict()

        # Constants
        self.constantHiInstrOffset: dict[int, int] = dict()
        "key: offset of instruction which is setting the %hi constant, value: constant"
        self.constantLoInstrOffset: dict[int, int] = dict()
        "key: offset of instruction which is setting the %lo constant, value: constant"

        self.constantInstrOffset: dict[int, int] = dict()

        # Symbols
        self.symbolHiInstrOffset: dict[int, int] = dict()
        "key: offset of instruction which is setting the %hi symbol, value: symbol"
        self.symbolLoInstrOffset: dict[int, int] = dict()
        "key: offset of instruction which is setting the %lo symbol, value: symbol"

        self.symbolGpInstrOffset: dict[int, int] = dict()

        self.symbolInstrOffset: dict[int, int] = dict()

        self.possibleSymbolTypes: dict[int, str] = dict()

        # %hi/%lo pairing
        self.hiToLowDict: dict[int, int] = dict()
        "key: %hi instruction offset, value: %lo instruction offset"
        self.lowToHiDict: dict[int, int] = dict()
        "key: %lo instruction offset, value: %hi instruction offset"


    def processBranch(self, instr: instructions.InstructionBase, instrOffset: int, currentVram: int) -> None:
        if instrOffset in self.branchInstrOffsets:
            # Already processed
            return

        if instr.uniqueId == instructions.InstructionId.J:
            targetBranchVram = instr.getInstrIndexAsVram()
            branch = instrOffset + targetBranchVram - currentVram
        else:
            branch = instrOffset + instr.getBranchOffset()
            targetBranchVram = self.funcVram + branch

        self.referencedVrams.add(targetBranchVram)

        # labelSym = self.addBranchLabel(targetBranchVram, isAutogenerated=True)
        # labelSym.referenceCounter += 1
        # self.localLabels[branch] = labelSym.getName()
        self.branchLabelOffsets.add(branch)
        self.branchInstrOffsets[instrOffset] = targetBranchVram
        self.branchTargetInstrOffsets[instrOffset] = branch

    def processFuncCall(self, instr: instructions.InstructionBase, instrOffset: int) -> None:
        if instrOffset in self.funcCallInstrOffsets:
            # Already processed
            return

        target = instr.getInstrIndexAsVram()
        # if not self.isRsp:
        #     if target >= 0x84000000:
        #         # RSP address space?
        #         self.isLikelyHandwritten = True
        if target >= 0x84000000 or target < 0x80000000:
            self.funcCallOutsideRangesOffsets[instrOffset] = target

        self.referencedVrams.add(target)
        self.referencedVramsInstrOffset[instrOffset] = target

        # funcSym = self.addFunction(target, isAutogenerated=True)
        # funcSym.referenceCounter += 1
        # self.pointersPerInstruction[instrOffset] = target
        self.funcCallInstrOffsets[instrOffset] = target


    def processConstant(self, luiInstr: instructions.InstructionBase, luiOffset: int, lowerInstr: instructions.InstructionBase, lowerOffset: int) -> int|None:
        upperHalf = luiInstr.immediate << 16
        lowerHalf = lowerInstr.immediate
        constant = upperHalf | lowerHalf

        self.referencedConstants.add(constant)

        self.constantHiInstrOffset[luiOffset] = constant
        self.constantLoInstrOffset[lowerOffset] = constant
        self.constantInstrOffset[luiOffset] = constant
        self.constantInstrOffset[lowerOffset] = constant

        self.hiToLowDict[luiOffset] = lowerOffset
        self.lowToHiDict[lowerOffset] = luiOffset

        return constant


    def pairHiLo(self, luiInstr: instructions.InstructionBase|None, luiOffset: int|None, lowerInstr: instructions.InstructionBase, lowerOffset: int) -> int|None:
        # lui being None means this symbol is a $gp access
        assert (luiInstr is None and luiOffset is None) or (luiInstr is not None and luiOffset is not None)

        lowerHalf = common.Utils.from2Complement(lowerInstr.immediate, 16)

        if lowerOffset in self.symbolLoInstrOffset:
            # This %lo has been processed already

            if common.GlobalConfig.COMPILER == common.Compiler.IDO:
                # IDO does not pair multiples %hi to the same %lo
                return self.symbolLoInstrOffset[lowerOffset]

            elif common.GlobalConfig.COMPILER in {common.Compiler.GCC, common.Compiler.SN64}:
                if luiOffset is None or luiInstr is None:
                    return None

                if self.hiToLowDict.get(luiOffset, None) == lowerOffset and self.lowToHiDict.get(lowerOffset, None) == luiOffset:
                    # This pair has been already paired
                    return self.symbolLoInstrOffset[lowerOffset]

                # luiInstrPrev = self.instructions[(luiOffset-4)//4]
                # if luiInstrPrev.isBranchLikely() or luiInstrPrev.isUnconditionalBranch():
                #     # This lui will be nullified afterwards, so it is likely for it to be re-used lui
                #     pass
                # elif luiInstrPrev.isBranch():
                #     # I'm not really sure if a lui on any branch slot is enough to believe this is really a symbol
                #     # Let's hope it does for now...
                #     pass
                # elif luiOffset + 4 == lowerOffset:
                if luiOffset + 4 == lowerOffset:
                    # Make an exception if the lower instruction is just after the LUI
                    pass
                else:
                    upperHalf = luiInstr.immediate << 16
                    address = upperHalf + lowerHalf
                    if address == self.symbolLoInstrOffset[lowerOffset]:
                        # Make an exception if the resulting address is the same
                        pass
                    else:
                        return self.symbolLoInstrOffset[lowerOffset]

        if luiInstr is None and common.GlobalConfig.GP_VALUE is None:
            # Trying to pair a gp relative offset, but we don't know the gp address
            return None

        if luiInstr is not None:
            upperHalf = luiInstr.immediate << 16
        else:
            assert common.GlobalConfig.GP_VALUE is not None
            upperHalf = common.GlobalConfig.GP_VALUE

        address = upperHalf + lowerHalf
        # if address in self.context.bannedSymbols:
        #     return None

        return address


    def processSymbol(self, address: int, luiOffset: int|None, lowerInstr: instructions.InstructionBase, lowerOffset: int) -> int|None:
        # filter out stuff that may not be a real symbol
        filterOut = common.GlobalConfig.SYMBOL_FINDER_FILTER_LOW_ADDRESSES and address < 0x40000000
        filterOut |= common.GlobalConfig.SYMBOL_FINDER_FILTER_HIGH_ADDRESSES and address >= 0xC0000000
        if filterOut:
            if common.GlobalConfig.SYMBOL_FINDER_FILTERED_ADDRESSES_AS_CONSTANTS:
                # Let's pretend this value is a constant
                constant = address
                self.referencedConstants.add(constant)

                self.constantLoInstrOffset[lowerOffset] = constant
                self.constantInstrOffset[lowerOffset] = constant
                if luiOffset is not None:
                    self.constantHiInstrOffset[luiOffset] = constant
                    self.constantInstrOffset[luiOffset] = constant

                    self.hiToLowDict[luiOffset] = lowerOffset
                    self.lowToHiDict[lowerOffset] = luiOffset
            return None

        # patchedAddress = address
        # patch = self.getLoPatch(lowerInstr.vram)
        # if patch is not None:
        #     patchedAddress = patch

        # self.referencedVrams.add(patchedAddress)
        # contextSym = self.getSymbol(patchedAddress)
        # if contextSym is None:
        #     if common.GlobalConfig.ADD_NEW_SYMBOLS:
        #         contextSym = self.addSymbol(patchedAddress, isAutogenerated=True)
        #         instrType = lowerInstr.mapInstrToType()
        #         if instrType is not None:
        #             contextSym.setTypeIfUnset(instrType)
        #         contextSym.referenceCounter += 1
        # else:
        #     contextSym.referenceCounter += 1

        self.referencedVrams.add(address)

        if lowerOffset not in self.symbolLoInstrOffset:
            self.symbolLoInstrOffset[lowerOffset] = address
            self.symbolInstrOffset[lowerOffset] = address
            self.referencedVramsInstrOffset[lowerOffset] = address
        if luiOffset is not None:
            if luiOffset not in self.symbolHiInstrOffset:
                self.symbolHiInstrOffset[luiOffset] = address
                self.symbolInstrOffset[luiOffset] = address
                self.referencedVramsInstrOffset[luiOffset] = address

            self.hiToLowDict[luiOffset] = lowerOffset
            self.lowToHiDict[lowerOffset] = luiOffset
        else:
            self.symbolGpInstrOffset[lowerOffset] = address
            self.symbolInstrOffset[lowerOffset] = address
            self.referencedVramsInstrOffset[lowerOffset] = address

        # instrType = lowerInstr.mapInstrToType()
        # if instrType is not None:
        #     contextSym.setTypeIfUnset(instrType)
        self.processSymbolType(address, lowerInstr, lowerOffset)

        return address

    def processSymbolType(self, address: int, instr: instructions.InstructionBase, instrOffset: int) -> None:
        instrType = instr.mapInstrToType()
        if instrType is None:
            return
        # address = regsTracker.getAddressIfCanSetType(instr, instrOffset)
        # if address is None:
        #     return

        # contextSym = self.getSymbol(address, tryPlusOffset=False)
        # if contextSym is not None:
        #     contextSym.setTypeIfUnset(instrType)
        if address not in self.possibleSymbolTypes:
            self.possibleSymbolTypes[address] = instrType

    def processSymbolDereferenceType(self, instr: instructions.InstructionBase, instrOffset: int, regsTracker: RegistersTracker) -> None:
        address = regsTracker.getAddressIfCanSetType(instr, instrOffset)
        if address is None:
            return

        # contextSym = self.getSymbol(address, tryPlusOffset=False)
        # if contextSym is not None:
        #     contextSym.setTypeIfUnset(instrType)

        self.processSymbolType(address, instr, instrOffset)


    def processJumpRegister(self, address: int, instrOffset: int, loOffset: int) -> None:
        # jrInfo = regsTracker.getJrInfo(instr)
        # if jrInfo is not None:
        #     offset, address = jrInfo
        #     self.referencedJumpTableOffsets.add(offset)
        #     self.referencedVRams.add(address)
        #     self.addJumpTable(address, isAutogenerated=True)

        self.referencedJumpTableOffsets[loOffset] = address
        self.jumpRegisterIntrOffset[instrOffset] = address
        self.referencedVrams.add(address)
