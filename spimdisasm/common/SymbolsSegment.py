#!/usr/bin/env python3

# SPDX-FileCopyrightText: Â© 2022 Decompollaborate
# SPDX-License-Identifier: MIT

from __future__ import annotations

from typing import TextIO, Generator
import bisect

from .GlobalConfig import GlobalConfig
from .FileSectionType import FileSectionType
from .ContextSymbols import SymbolSpecialType, ContextSymbol


class SymbolsSegment:
    def __init__(self):
        self.symbols: dict[int, ContextSymbol] = dict()
        self.symbolsVramSorted: list[int] = list()

        self.constants: dict[int, ContextSymbol] = dict()


    def getSymbol(self, vramAddress: int, tryPlusOffset: bool = True, checkUpperLimit: bool = True) -> ContextSymbol|None:
        "Searches symbol or a symbol with an addend if `tryPlusOffset` is True"
        if vramAddress == 0:
            return None

        if vramAddress in self.symbols:
            return self.symbols[vramAddress]

        if GlobalConfig.PRODUCE_SYMBOLS_PLUS_OFFSET and tryPlusOffset:
            vramIndex = bisect.bisect(self.symbolsVramSorted, vramAddress)
            if vramIndex != len(self.symbolsVramSorted):
                symVram = self.symbolsVramSorted[vramIndex-1]
                contextSym = self.symbols[symVram]

                if vramAddress > symVram:
                    if checkUpperLimit and vramAddress >= symVram + contextSym.size:
                        return None
                    return contextSym
        return None

    def getSymbolRangeIter(self, addressStart: int, addressEnd: int) -> Generator[ContextSymbol, None, None]:
        vramIndexLow = bisect.bisect(self.symbolsVramSorted, addressStart)
        vramIndexHigh = bisect.bisect(self.symbolsVramSorted, addressEnd)
        for vramIndex in range(vramIndexLow-1, vramIndexHigh-1):
            symbolVram = self.symbolsVramSorted[vramIndex]
            yield self.symbols[symbolVram]

    def getSymbolRange(self, addressStart: int, addressEnd: int):
        return list(self.getSymbolRangeIter(addressStart, addressEnd))

    def getConstant(self, constantValue: int) -> ContextSymbol|None:
        return self.constants.get(constantValue, None)


    def addSymbol(self, vramAddress: int, name: str|None=None, sectionType: FileSectionType=FileSectionType.Unknown, isAutogenerated: bool=False) -> ContextSymbol:
        contextSymbol = self.symbols.get(vramAddress, None)
        if contextSymbol is None:
            # contextSymbol = ContextSymbol(vramAddress, name)
            contextSymbol = ContextSymbol(name)
            contextSymbol.address = vramAddress
            contextSymbol.isAutogenerated = isAutogenerated
            contextSymbol.sectionType = sectionType
            self.symbols[vramAddress] = contextSymbol
            bisect.insort(self.symbolsVramSorted, vramAddress)

        if contextSymbol.isAutogenerated and name is not None:
            contextSymbol.name = name
        if contextSymbol.sectionType == FileSectionType.Unknown:
            contextSymbol.sectionType = sectionType

        return contextSymbol

    def addFunction(self, vramAddress: int, name: str|None=None, isAutogenerated: bool=False) -> ContextSymbol:
        contextSymbol = self.addSymbol(vramAddress, name, FileSectionType.Text, isAutogenerated=isAutogenerated)
        if contextSymbol.type != SymbolSpecialType.jumptablelabel:
            contextSymbol.type = SymbolSpecialType.function
        contextSymbol.sectionType = FileSectionType.Text
        return contextSymbol

    def addBranchLabel(self, vramAddress: int, name: str|None=None, isAutogenerated: bool=False) -> ContextSymbol:
        contextSymbol = self.addSymbol(vramAddress, name, isAutogenerated=isAutogenerated)
        if contextSymbol.type != SymbolSpecialType.jumptablelabel and contextSymbol.type != SymbolSpecialType.function:
            contextSymbol.type = SymbolSpecialType.branchlabel
        return contextSymbol

    def addJumpTable(self, vramAddress: int, name: str|None=None, isAutogenerated: bool=False) -> ContextSymbol:
        contextSymbol = self.addSymbol(vramAddress, name, FileSectionType.Rodata, isAutogenerated=isAutogenerated)
        if contextSymbol.type != SymbolSpecialType.function:
            contextSymbol.type = SymbolSpecialType.jumptable
        return contextSymbol

    def addJumpTableLabel(self, vramAddress: int, name: str|None=None, isAutogenerated: bool=False) -> ContextSymbol:
        contextSymbol = self.addSymbol(vramAddress, name, FileSectionType.Text, isAutogenerated=isAutogenerated)
        contextSymbol.type = SymbolSpecialType.jumptablelabel
        contextSymbol.sectionType = FileSectionType.Text
        return contextSymbol


    def addConstant(self, constantValue: int, name: str) -> ContextSymbol:
        if constantValue not in self.constants:
            # contextSymbol = ContextSymbol(constantValue, name)
            contextSymbol = ContextSymbol(name)
            contextSymbol.address = constantValue
            contextSymbol.type = SymbolSpecialType.constant
            self.constants[constantValue] = contextSymbol
            return contextSymbol
        return self.constants[constantValue]


    def saveContextToFile(self, f: TextIO):
        for address, symbol in self.symbols.items():
            f.write(f"symbol,{symbol.toCsv()}\n")

        for address, constant in self.constants.items():
            f.write(f"constants,{constant.toCsv()}\n")
