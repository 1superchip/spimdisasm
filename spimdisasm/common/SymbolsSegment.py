#!/usr/bin/env python3

# SPDX-FileCopyrightText: Â© 2022 Decompollaborate
# SPDX-License-Identifier: MIT

from __future__ import annotations

from typing import TextIO, Generator
import bisect

from .GlobalConfig import GlobalConfig
from .FileSectionType import FileSectionType
from .ContextSymbols import SymbolSpecialType, ContextSymbol


class SymbolsSegment:
    def __init__(self, vramStart: int, vramEnd: int, isOverlay: bool=False):
        assert vramStart < vramEnd

        self.vramStart: int = vramStart
        self.vramEnd: int = vramEnd

        self.isOverlay: bool = isOverlay

        self.symbols: dict[int, ContextSymbol] = dict()
        self.symbolsVramSorted: list[int] = list()

        self.constants: dict[int, ContextSymbol] = dict()


    def isVramInRange(self, vram: int) -> bool:
        return self.vramStart <= vram < self.vramEnd

    def extendRange(self, vramEnd: int) -> None:
        if self.vramEnd < vramEnd:
            self.vramEnd = vramEnd


    def getSymbol(self, address: int, tryPlusOffset: bool = True, checkUpperLimit: bool = True) -> ContextSymbol|None:
        "Searches symbol or a symbol with an addend if `tryPlusOffset` is True"
        if address == 0:
            return None

        if address in self.symbols:
            return self.symbols[address]

        if GlobalConfig.PRODUCE_SYMBOLS_PLUS_OFFSET and tryPlusOffset:
            vramIndex = bisect.bisect(self.symbolsVramSorted, address)
            if vramIndex != len(self.symbolsVramSorted):
                symVram = self.symbolsVramSorted[vramIndex-1]
                contextSym = self.symbols[symVram]

                if address > symVram:
                    if checkUpperLimit and address >= symVram + contextSym.getSize():
                        return None
                    return contextSym
        return None

    def getSymbolRangeIter(self, addressStart: int, addressEnd: int) -> Generator[ContextSymbol, None, None]:
        vramIndexLow = bisect.bisect(self.symbolsVramSorted, addressStart)
        vramIndexHigh = bisect.bisect(self.symbolsVramSorted, addressEnd)
        for vramIndex in range(vramIndexLow-1, vramIndexHigh-1):
            symbolVram = self.symbolsVramSorted[vramIndex]
            yield self.symbols[symbolVram]

    def getSymbolRange(self, addressStart: int, addressEnd: int):
        return list(self.getSymbolRangeIter(addressStart, addressEnd))

    def getConstant(self, constantValue: int) -> ContextSymbol|None:
        return self.constants.get(constantValue, None)


    def addSymbol(self, address: int, sectionType: FileSectionType=FileSectionType.Unknown, isAutogenerated: bool=False) -> ContextSymbol:
        contextSymbol = self.symbols.get(address, None)
        if contextSymbol is None:
            contextSymbol = ContextSymbol(address)
            contextSymbol.isAutogenerated = isAutogenerated
            contextSymbol.sectionType = sectionType
            contextSymbol.isOverlay = self.isOverlay
            self.symbols[address] = contextSymbol
            bisect.insort(self.symbolsVramSorted, address)

        if contextSymbol.sectionType == FileSectionType.Unknown:
            contextSymbol.sectionType = sectionType

        return contextSymbol

    def addFunction(self, address: int, isAutogenerated: bool=False) -> ContextSymbol:
        contextSymbol = self.addSymbol(address, sectionType=FileSectionType.Text, isAutogenerated=isAutogenerated)
        if contextSymbol.type != SymbolSpecialType.jumptablelabel:
            contextSymbol.type = SymbolSpecialType.function
        contextSymbol.sectionType = FileSectionType.Text
        return contextSymbol

    def addBranchLabel(self, address: int, isAutogenerated: bool=False) -> ContextSymbol:
        contextSymbol = self.addSymbol(address, sectionType=FileSectionType.Text, isAutogenerated=isAutogenerated)
        if contextSymbol.type != SymbolSpecialType.jumptablelabel and contextSymbol.type != SymbolSpecialType.function:
            contextSymbol.type = SymbolSpecialType.branchlabel
        return contextSymbol

    def addJumpTable(self, address: int, isAutogenerated: bool=False) -> ContextSymbol:
        contextSymbol = self.addSymbol(address, sectionType=FileSectionType.Rodata, isAutogenerated=isAutogenerated)
        if contextSymbol.type != SymbolSpecialType.function:
            contextSymbol.type = SymbolSpecialType.jumptable
        return contextSymbol

    def addJumpTableLabel(self, address: int, isAutogenerated: bool=False) -> ContextSymbol:
        contextSymbol = self.addSymbol(address, sectionType=FileSectionType.Text, isAutogenerated=isAutogenerated)
        contextSymbol.type = SymbolSpecialType.jumptablelabel
        contextSymbol.sectionType = FileSectionType.Text
        return contextSymbol


    def addConstant(self, constantValue: int, name: str) -> ContextSymbol:
        if constantValue not in self.constants:
            contextSymbol = ContextSymbol(constantValue)
            contextSymbol.name = name
            contextSymbol.type = SymbolSpecialType.constant
            self.constants[constantValue] = contextSymbol
            return contextSymbol
        return self.constants[constantValue]


    def saveContextToFile(self, f: TextIO):
        for address, symbol in self.symbols.items():
            f.write(f"symbol,{symbol.toCsv()}\n")

        for address, constant in self.constants.items():
            f.write(f"constants,{constant.toCsv()}\n")
